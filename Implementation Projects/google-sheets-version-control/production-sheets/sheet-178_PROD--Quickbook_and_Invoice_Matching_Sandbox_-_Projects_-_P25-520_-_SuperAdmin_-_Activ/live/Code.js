



/**
 * Sheets Matching Engine — Configurable row matcher for Google Sheets
 * Author: Rashid Khan (generated by ChatGPT — Senior Google Apps Script engineer)
 *
 * ============================= HOW TO USE =============================
 * 1) In your Google Sheet, open Extensions → Apps Script and paste this file.
 * 2) Reload the spreadsheet; a menu "Matching Engine" will appear.
 * 3) Click Matching Engine → Setup. This creates a "Config" sheet with headers
 *    and attempts a stub mapping using overlapping headers between Destination & Source.
 * 4) Edit the Config rows to define mappings and rules. See examples at bottom of this file.
 * 5) Run Matching Engine → Preview (non-destructive) to see results in the
 *    "Matching Preview" sheet.
 * 6) Run Matching Engine → Run (writes results) to write outputs to Destination
 *    starting from the configured outputStartCol (default "G").
 *
 * Options (for programmatic use):
 *   runMatching({
 *     destinationSheetName: 'Destination',
 *     sourceSheetName: 'Source',
 *     configSheetName: 'Config',
 *     outputStartCol: 'G',
 *     minCompositeScore: 80,
 *     previewMode: false
 *   })
 *
 * Output columns (starting at outputStartCol):
 *   Matched? | Match Score | Source Row | Diagnostics | <one column per Output Field?=yes mapping>
 *
 * Types & Modes:
 *   Type: text | number | date
 *   Match Mode: exact | dynamic
 *     - text/dynamic: fuzzy similarity [0..100] using token-set ratio (with Jaro–Winkler fallback);
 *                     per-field Threshold (0–100) from Config is used as a floor: scores below threshold -> 0.
 *     - number/dynamic: inclusive range; Range A & B are offsets relative to Destination value (e.g., -2, +2).
 *                       If Destination value is empty, or both A/B look like absolute bounds, treat as absolute [A..B].
 *                       Scoring decays linearly from 100 at the range center to 0 at range edges.
 *     - date/dynamic: offsets like -3d/+3d (also supports w=weeks, m=months), or absolute dates (yyyy-mm-dd).
 *                     Inclusive; same linear decay as numbers. Dates normalized to local calendar days.
 *
 * Safety:
 *   - Missing headers in Destination/Source are logged and skipped. Engine won’t crash.
 *   - If no valid fields exist for a row, Matched?=FALSE and Score=0.
 *   - Batch I/O and single-pass loops for up to ~50k Source rows.
 *
 * Telemetry:
 *   - Logs totals, avg candidates evaluated per row, match rate.
 *
 * =====================================================================
 */

/**************
 * UI Helpers *
 **************/
// function onOpen() {
//   const ui = SpreadsheetApp.getUi();
//   ui.createMenu('Matching Engine')
//     .addItem('Setup', 'setup')
//     .addSeparator()
//     .addItem('Preview', 'runPreview')
//     .addItem('Run (Write Results)', 'runWrite')
//     .addToUi();
// }

function runPreview() {
  runMatching({ previewMode: true });
}

function runWrite() {
  runMatching({ previewMode: false });
}

/**********************
 * Public Entry Point *
 **********************/
function runMatching(options) {
  const defaults = {
    destinationSheetName: 'Destination',
    sourceSheetName: 'Source',
    configSheetName: 'Config',
    outputStartCol: 'G',
    minCompositeScore: 80,
    previewMode: false
  };
  const opts = Object.assign({}, defaults, options || {});

  const ss = SpreadsheetApp.getActive();
  const destSheet = ss.getSheetByName(opts.destinationSheetName);
  const srcSheet = ss.getSheetByName(opts.sourceSheetName);
  const cfgSheet = ss.getSheetByName(opts.configSheetName);

  if (!destSheet) throw new Error('Destination sheet not found: ' + opts.destinationSheetName);
  if (!srcSheet) throw new Error('Source sheet not found: ' + opts.sourceSheetName);
  if (!cfgSheet) throw new Error('Config sheet not found: ' + opts.configSheetName + '. Run setup().');

  // Read sheets
  const destData = readSheetAsObjects(opts.destinationSheetName);
  const srcData = readSheetAsObjects(opts.sourceSheetName);
  const cfgData = readSheetAsObjects(opts.configSheetName);

  // Build mappings and output plan
  const { mappings, outputPlan, warnings } = buildMappings(cfgData.rows, destData.headers, srcData.headers);
  if (warnings.length) warnings.forEach(w => Logger.log('CONFIG WARNING: ' + w));
  if (!mappings.length) throw new Error('No valid mappings found in Config. Please configure at least one row.');

  // Pre-index source for exact matches (per mapping)
  const exactIndexes = buildExactIndexes(srcData, mappings);

  // Candidate evaluation & scoring
  const minScore = Number(opts.minCompositeScore) || 80;
  const results = [];
  let totalCandidatesEvaluated = 0;
  let matchedCount = 0;

  for (let i = 0; i < destData.rows.length; i++) {
    const dRow = destData.rows[i];
    const candidateIdxs = getCandidateIndicesForRow(dRow, srcData, mappings, exactIndexes);
    totalCandidatesEvaluated += candidateIdxs.length;

    let best = { index: -1, composite: 0, fieldScores: {}, diagnostics: '', passed: false };

    for (let k = 0; k < candidateIdxs.length; k++) {
      const idx = candidateIdxs[k];
      const sRow = srcData.rows[idx];
      const scored = scoreRow(dRow, sRow, mappings);
      if (scored.composite > best.composite) {
        best = Object.assign({ index: idx }, scored);
      }
    }

    const passed = best.composite >= minScore;
    if (passed) matchedCount++;

    results.push({
      destIndex: i,
      matched: passed,
      score: round2(best.composite),
      sourceIndex: best.index >= 0 ? best.index : '',
      diagnostics: buildDiagnostics(best.fieldScores),
      fieldScores: best.fieldScores
    });
  }

  // Write outputs
  if (opts.previewMode) {
    writePreviewSheet(results, destData, srcData, outputPlan);
  } else {
    writeResults(destSheet, results, srcData, outputPlan, opts.outputStartCol);
  }

  // Telemetry
  const avgCandidates = destData.rows.length ? (totalCandidatesEvaluated / destData.rows.length) : 0;
  const matchRate = destData.rows.length ? (matchedCount / destData.rows.length) * 100 : 0;
  Logger.log('[Matching Engine] Processed %s destination rows. Avg candidates/row: %s. Match rate: %s%%.', destData.rows.length, round2(avgCandidates), round2(matchRate));

  return {
    destinationRows: destData.rows.length,
    sourceRows: srcData.rows.length,
    avgCandidatesEvaluated: round2(avgCandidates),
    matchRatePercent: round2(matchRate)
  };
}

/********************************
 * Sheet Read/Write + Structures *
 ********************************/
function readSheetAsObjects(sheetName) {
  const sheet = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sheet) throw new Error('Sheet not found: ' + sheetName);
  const rng = sheet.getDataRange();
  const values = rng.getValues();
  if (!values.length) return { headers: [], headerMap: {}, rows: [] };

  const headers = (values[0] || []).map(h => String(h || '').trim());
  const headerMap = {};
  const seen = {};
  headers.forEach((h, idx) => {
    const key = normalizeHeader(h);
    if (seen[key]) {
      Logger.log('DUPLICATE HEADER WARNING in %s: "%s" (normalized: %s). Using first occurrence.', sheetName, h, key);
      return; // keep first occurrence
    }
    seen[key] = true;
    headerMap[key] = { name: h, index: idx };
  });

  const rows = [];
  for (let r = 1; r < values.length; r++) {
    const rowArr = values[r];
    const obj = {};
    Object.keys(headerMap).forEach(k => {
      const idx = headerMap[k].index;
      obj[headerMap[k].name] = rowArr[idx];
    });
    rows.push(obj);
  }
  return { headers, headerMap, rows, rawValues: values };
}

function writeResults(destSheet, results, srcData, outputPlan, outputStartCol) {
  const startCol = typeof outputStartCol === 'number' ? outputStartCol : letterToCol(String(outputStartCol || 'G'));
  const startRow = 2; // below headers

  // Build header row (if needed) — we will write 1 row of headers starting at outputStartCol
  const headers = ['Matched?', 'Match Score', 'Source Row', 'Diagnostics'].concat(outputPlan.map(m => m.sourceHeader));
  destSheet.getRange(1, startCol, 1, headers.length).setValues([headers]);

  // Build result matrix aligned with destination rows
  const out = results.map(res => {
    const sIdx = res.sourceIndex;
    const sRow = (typeof sIdx === 'number' && sIdx >= 0) ? srcData.rows[sIdx] : null;
    const outFields = outputPlan.map(m => sRow ? sRow[m.sourceHeader] : '');
    const sourceRowDisplay = (typeof sIdx === 'number' && sIdx >= 0) ? (sIdx + 2) : '';// source sheet display row
    return [res.matched, res.score, sourceRowDisplay, res.diagnostics].concat(outFields);
  });

  destSheet.getRange(startRow, startCol, out.length, headers.length).setValues(out);
}

function writePreviewSheet(results, destData, srcData, outputPlan) {
  const ss = SpreadsheetApp.getActive();
  const name = 'Matching Preview';
  let sheet = ss.getSheetByName(name);
  if (!sheet) sheet = ss.insertSheet(name);
  sheet.clear();

  const headers = ['Dest Row', 'Matched?', 'Match Score', 'Source Row', 'Diagnostics'].concat(outputPlan.map(m => m.sourceHeader));
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);

  const out = results.map((res, i) => {
    const sIdx = res.sourceIndex;
    const sRow = (typeof sIdx === 'number' && sIdx >= 0) ? srcData.rows[sIdx] : null;
    const outFields = outputPlan.map(m => sRow ? sRow[m.sourceHeader] : '');
    const srcDisplay = (typeof sIdx === 'number' && sIdx >= 0) ? (sIdx + 2) : '';
    return [i + 2, res.matched, res.score, srcDisplay, res.diagnostics].concat(outFields);
  });

  if (out.length) sheet.getRange(2, 1, out.length, headers.length).setValues(out);
  sheet.autoResizeColumns(1, headers.length);
}

/*********************
 * Mapping & Scoring *
 *********************/
function buildMappings(configRows, destHeaders, srcHeaders) {
  const destHeaderNorm = indexByNormalizedHeader(destHeaders);
  const srcHeaderNorm = indexByNormalizedHeader(srcHeaders);

  const mappings = [];
  const outputPlan = [];
  const warnings = [];

  for (let i = 0; i < configRows.length; i++) {
    const row = configRows[i];
    const destHeader = String(row['Dest Header'] || '').trim();
    const srcHeader = String(row['Source Header'] || '').trim();
    if (!destHeader && !srcHeader) continue; // skip blank config rows

    const type = String(row['Type (text/number/date)'] || row['Type'] || '').toLowerCase().trim();
    const mode = String(row['Match Mode (exact/dynamic)'] || row['Match Mode'] || '').toLowerCase().trim();
    const thrA = String(row['Threshold / Range A'] || '').trim();
    const rangeB = String(row['Range B'] || '').trim();
    const weight = parseFloatSafe(row['Weight (0–1)'], 1);
    const outputFieldFlag = String(row['Output Field? (yes/no)'] || '').toLowerCase().indexOf('y') === 0;

    // Resolve actual headers by normalized lookup (case-insensitive, punctuation agnostic)
    const destResolved = destHeaderNorm[normalizeHeader(destHeader)] || null;
    const srcResolved = srcHeaderNorm[normalizeHeader(srcHeader)] || null;

    if (!destResolved) warnings.push(`Row ${i + 2}: Destination header "${destHeader}" not found in Destination sheet; mapping will be skipped.`);
    if (!srcResolved) warnings.push(`Row ${i + 2}: Source header "${srcHeader}" not found in Source sheet; mapping will be skipped.`);

    const valid = !!(destResolved && srcResolved && type && mode);
    if (!valid) continue;

    const mapping = {
      destHeader: destResolved.original,
      sourceHeader: srcResolved.original,
      type,
      mode,
      thrA, // text threshold or number/date Range A
      rangeB, // number/date Range B
      weight: isFinite(weight) ? weight : 1,
      output: outputFieldFlag
    };
    mappings.push(mapping);
    if (outputFieldFlag) outputPlan.push(mapping);
  }

  return { mappings, outputPlan, warnings };
}

function scoreRow(destRow, sourceRow, mappings) {
  const fieldScores = {};
  let sum = 0;
  let wsum = 0;

  for (let i = 0; i < mappings.length; i++) {
    const m = mappings[i];
    const dValRaw = destRow[m.destHeader];
    const sValRaw = sourceRow[m.sourceHeader];
    let score = 0;

    if (m.type === 'text') {
      const dNorm = normalizeTextForCompare(dValRaw);
      const sNorm = normalizeTextForCompare(sValRaw);
      if (m.mode === 'exact') {
        score = (dNorm && sNorm && dNorm === sNorm) ? 100 : 0;
      } else {
        const sim = similarity_text(dNorm, sNorm); // 0..100
        const threshold = parseFloatSafe(m.thrA, 0);
        score = sim >= threshold ? sim : 0; // enforce per-field threshold
      }
    } else if (m.type === 'number') {
      const dNum = parseFloatSafe(dValRaw, null);
      const sNum = parseFloatSafe(sValRaw, null);
      if (m.mode === 'exact') {
        score = (dNum !== null && sNum !== null && dNum === sNum) ? 100 : 0;
      } else {
        score = similarity_number(dNum, sNum, m.thrA, m.rangeB);
      }
    } else if (m.type === 'date') {
      const dDate = parseAsDateOrNull(dValRaw);
      const sDate = parseAsDateOrNull(sValRaw);
      if (m.mode === 'exact') {
        score = (dDate && sDate && sameCalendarDate(dDate, sDate)) ? 100 : 0;
      } else {
        score = similarity_date(dDate, sDate, m.thrA, m.rangeB);
      }
    } else {
      // unknown type; skip
      continue;
    }

    fieldScores[m.destHeader + '⇄' + m.sourceHeader] = round2(score);

    if (isFinite(m.weight) && m.weight > 0 && isFinite(score)) {
      sum += (score * m.weight);
      wsum += m.weight;
    }
  }

  const composite = wsum > 0 ? (sum / wsum) : 0;
  return { fieldScores, composite, passed: isFinite(composite) && composite >= 0 };
}

function selectBest(sourceRows, scorer, minScore) {
  let best = { index: -1, composite: 0, fieldScores: {}, diagnostics: '', passed: false };
  for (let i = 0; i < sourceRows.length; i++) {
    const s = sourceRows[i];
    const scored = scorer(s);
    if (scored.composite > best.composite) {
      best = Object.assign({ index: i }, scored);
    }
  }
  best.passed = best.composite >= (minScore || 80);
  best.diagnostics = buildDiagnostics(best.fieldScores);
  return best;
}

function buildDiagnostics(fieldScores) {
  const parts = [];
  for (const k in fieldScores) parts.push(k + ':' + round2(fieldScores[k]));
  return parts.join('|');
}

/*************************
 * Candidate Optimization *
 *************************/
function buildExactIndexes(srcData, mappings) {
  // For each exact mapping, build an index map: key -> [rowIndices]
  // Key format depends on type (text normalized, number as-is, date yyyy-mm-dd)
  const indexes = [];
  mappings.forEach(m => {
    if (m.mode !== 'exact') return;
    const idx = new Map();
    for (let i = 0; i < srcData.rows.length; i++) {
      const row = srcData.rows[i];
      const v = row[m.sourceHeader];
      let key = null;
      if (m.type === 'text') key = normalizeTextForCompare(v);
      else if (m.type === 'number') key = isFinite(parseFloat(v)) ? String(parseFloat(v)) : null;
      else if (m.type === 'date') {
        const d = parseAsDateOrNull(v);
        key = d ? formatYMD(d) : null;
      }
      if (key) {
        if (!idx.has(key)) idx.set(key, []);
        idx.get(key).push(i);
      }
    }
    indexes.push({ mapping: m, index: idx });
  });
  return indexes;
}

function getCandidateIndicesForRow(destRow, srcData, mappings, exactIndexes) {
  // Intersect candidate sets from all exact mappings. If none found or no exacts, fall back to full scan.
  const candidateSets = [];
  exactIndexes.forEach(ix => {
    const m = ix.mapping;
    const dValRaw = destRow[m.destHeader];
    let key = null;
    if (m.type === 'text') key = normalizeTextForCompare(dValRaw);
    else if (m.type === 'number') {
      const v = parseFloatSafe(dValRaw, null);
      key = v !== null ? String(v) : null;
    } else if (m.type === 'date') {
      const d = parseAsDateOrNull(dValRaw);
      key = d ? formatYMD(d) : null;
    }
    if (key && ix.index.has(key)) {
      candidateSets.push(new Set(ix.index.get(key)));
    } else {
      candidateSets.push(new Set());
    }
  });

  let candidates;
  if (candidateSets.length) {
    // Intersect all sets
    const intersected = candidateSets.reduce((acc, set) => {
      if (acc === null) return new Set(set);
      const next = new Set();
      acc.forEach(v => { if (set.has(v)) next.add(v); });
      return next;
    }, null);
    candidates = Array.from(intersected || []);
  }

  if (!candidates || candidates.length === 0) {
    // Fallback: all rows
    candidates = Array.from({ length: srcData.rows.length }, (_, i) => i);
  }
  return candidates;
}

/*******************
 * Similarity Core *
 *******************/
function similarity_text(a, b) {
  if (!a || !b) return 0;
  // Token-set ratio (order-agnostic) using Jaccard-like measure on tokens, boosted by Jaro–Winkler
  const ta = tokenize(a);
  const tb = tokenize(b);
  const setA = new Set(ta);
  const setB = new Set(tb);
  let inter = 0;
  setA.forEach(x => { if (setB.has(x)) inter++; });
  const jaccard = (inter === 0) ? 0 : (200 * inter) / (setA.size + setB.size); // scaled to [0..100]

  const jw = jaroWinkler(a, b) * 100; // [0..100]
  // Take a weighted max to handle both token reordering and typos
  // If tokens match strongly, jaccard dominates; otherwise JW helps partial/typo cases.
  return Math.max(jaccard, (jaccard * 0.6 + jw * 0.4));
}

function similarity_number(dNum, sNum, rangeA, rangeB) {
  if (dNum === null || sNum === null) return 0;
  const a = parseFloatSafe(rangeA, null);
  const b = parseFloatSafe(rangeB, null);

  if (a === null && b === null) {
    // No range: fallback to exact
    return dNum === sNum ? 100 : 0;
  }

  // Detect absolute vs relative bounds
  // If destination is null (already handled), or sNum fits within [a..b] and that window makes sense, treat as absolute.
  let useAbsolute = false;
  if (a !== null && b !== null && a <= b) {
    // If |b - a| is much larger than |dNum| window or destination is near center, heuristic is OK either way.
    // Heuristic: if sNum ∈ [a, b] and dNum ∉ [dNum + a, dNum + b] always (which is impossible), prefer absolute when dNum is null (already filtered) or when a/b look far from dNum.
    // Simpler: if |(a+b)/2 - dNum| > |(b-a)|, assume absolute bounds.
    if (Math.abs(((a + b) / 2) - dNum) > Math.abs(b - a)) useAbsolute = true;
  }

  let lo, hi, center;
  if (useAbsolute || dNum === null || (a !== null && b !== null && sNum >= a && sNum <= b && Math.abs(a - b) > 0)) {
    lo = (a !== null ? a : sNum);
    hi = (b !== null ? b : sNum);
    if (lo > hi) { const t = lo; lo = hi; hi = t; }
    center = (lo + hi) / 2;
  } else {
    const offA = (a !== null ? a : 0);
    const offB = (b !== null ? b : 0);
    lo = dNum + Math.min(offA, offB);
    hi = dNum + Math.max(offA, offB);
    center = dNum + ((offA + offB) / 2);
  }

  if (sNum < lo || sNum > hi) return 0;
  const half = (hi - lo) / 2;
  if (half <= 0) return 0;
  const dist = Math.abs(sNum - center);
  const score = Math.max(0, 100 * (1 - (dist / half)));
  return round2(score);
}

function similarity_date(dDate, sDate, rangeA, rangeB) {
  if (!dDate || !sDate) return 0;
  // Parse ranges: offsets like -3d/+3d, -2w/+1w, -1m/+1m OR absolute dates yyyy-mm-dd
  const ra = parseDateRangeBound(rangeA);
  const rb = parseDateRangeBound(rangeB);

  if (!ra && !rb) {
    // No range: exact calendar day
    return sameCalendarDate(dDate, sDate) ? 100 : 0;
  }

  // Compute [lo..hi] window either absolute or relative to dest
  let lo, hi;
  if ((ra && ra.absDate) || (rb && rb.absDate)) {
    // Absolute window if either bound is absolute date
    lo = ra && ra.absDate ? startOfDay(ra.absDate) : startOfDay(sDate);
    hi = rb && rb.absDate ? startOfDay(rb.absDate) : startOfDay(sDate);
    if (lo > hi) { const t = lo; lo = hi; hi = t; }
  } else {
    // Relative offsets
    const offA = ra ? ra.offset : { days: 0 };
    const offB = rb ? rb.offset : { days: 0 };
    lo = applyDateOffset(startOfDay(dDate), minOffset(offA, offB));
    hi = applyDateOffset(startOfDay(dDate), maxOffset(offA, offB));
  }

  const s = startOfDay(sDate);
  if (s < lo || s > hi) return 0;

  const centerTime = lo.getTime() + (hi.getTime() - lo.getTime()) / 2;
  const center = new Date(centerTime);
  const halfMs = (hi.getTime() - lo.getTime()) / 2;
  if (halfMs <= 0) return 0;
  const dist = Math.abs(s.getTime() - center.getTime());
  const score = Math.max(0, 100 * (1 - (dist / halfMs)));
  return round2(score);
}

/********************
 * Parsing & Normal *
 ********************/
function normalizeHeader(h) {
  return String(h || '').toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim().replace(/\s+/g, ' ');
}

function indexByNormalizedHeader(headers) {
  const map = {};
  headers.forEach(h => {
    const key = normalizeHeader(h);
    if (!map[key]) map[key] = { original: h };
  });
  return map;
}

function parseFloatSafe(v, fallback) {
  if (v === null || v === undefined || v === '') return fallback;
  const n = Number(v);
  return isFinite(n) ? n : fallback;
}

function normalizeTextForCompare(v) {
  if (v === null || v === undefined) return '';
  const s = String(v).toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '') // strip diacritics
    .replace(/[^a-z0-9]+/g, ' ') // keep alphanumerics
    .trim()
    .replace(/\s+/g, ' ');
  return s;
}

function tokenize(v) {
  if (!v) return [];
  return v.split(' ').filter(Boolean);
}

function parseAsDateOrNull(v) {
  if (v === null || v === undefined || v === '') return null;
  if (v instanceof Date) return v;
  // Try numeric (Excel serial) -> Apps Script usually provides Date already; but handle text
  const s = String(v).trim();
  const d = tryParseDateString(s);
  return d ? d : null;
}

function tryParseDateString(s) {
  // Try yyyy-mm-dd first
  const iso = /^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/;
  const m = s.match(iso);
  if (m) {
    const y = Number(m[1]), mo = Number(m[2]) - 1, d = Number(m[3]);
    const dt = new Date(y, mo, d);
    if (!isNaN(dt.getTime())) return dt;
  }
  // Fallback to Date()
  const dt2 = new Date(s);
  if (!isNaN(dt2.getTime())) return dt2;
  return null;
}

function startOfDay(d) {
  const dt = new Date(d.getTime());
  dt.setHours(0, 0, 0, 0);
  return dt;
}

function sameCalendarDate(a, b) {
  const da = startOfDay(a), db = startOfDay(b);
  return da.getTime() === db.getTime();
}

function formatYMD(d) {
  const y = d.getFullYear();
  const m = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  return `${y}-${m}-${day}`;
}

function letterToCol(letter) {
  let col = 0;
  const l = letter.toUpperCase();
  for (let i = 0; i < l.length; i++) {
    col = col * 26 + (l.charCodeAt(i) - 64);
  }
  return col;
}

function colToLetter(col) {
  let temp, letter = '';
  while (col > 0) {
    temp = (col - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    col = (col - temp - 1) / 26;
  }
  return letter;
}

function round2(x) { return Math.round((x + Number.EPSILON) * 100) / 100; }

/*******************
 * Date Range Parse *
 *******************/
function parseDateRangeBound(raw) {
  if (!raw) return null;
  const s = String(raw).trim();
  // Absolute date
  const abs = tryParseDateString(s);
  if (abs) return { absDate: abs };

  // Relative offsets like -3d, +2w, -1m
  const m = s.match(/^([+-]?\d+)\s*([dDwWmM])$/);
  if (m) {
    const val = parseInt(m[1], 10);
    const unit = m[2].toLowerCase();
    const off = { days: 0 };
    if (unit === 'd') off.days = val;
    else if (unit === 'w') off.days = val * 7;
    else if (unit === 'm') off.months = val; // month handling below
    return { offset: off };
  }
  return null;
}

function minOffset(a, b) {
  // Compare offsets by an approximate day count; handle months by 30d approximation for ordering only
  const daysA = (a.days || 0) + (a.months ? a.months * 30 : 0);
  const daysB = (b.days || 0) + (b.months ? b.months * 30 : 0);
  return daysA <= daysB ? a : b;
}

function maxOffset(a, b) {
  const daysA = (a.days || 0) + (a.months ? a.months * 30 : 0);
  const daysB = (b.days || 0) + (b.months ? b.months * 30 : 0);
  return daysA >= daysB ? a : b;
}

function applyDateOffset(base, off) {
  const d = new Date(base.getTime());
  if (off.months) {
    d.setMonth(d.getMonth() + off.months);
  }
  if (off.days) {
    d.setDate(d.getDate() + off.days);
  }
  d.setHours(0, 0, 0, 0);
  return d;
}

/**********************
 * Jaro–Winkler (JS)  *
 **********************/
function jaroWinkler(s1, s2) {
  if (!s1 || !s2) return 0;
  const mtp = matches(s1, s2);
  const m = mtp[0];
  if (m === 0) return 0;
  const j = ((m / s1.length) + (m / s2.length) + ((m - mtp[1]) / m)) / 3;
  const p = 0.1; // scaling factor
  const l = Math.min(mtp[2], 4);
  return j < 0.7 ? j : j + l * p * (1 - j);

  function matches(s1, s2) {
    const max = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;
    const match1 = new Array(s1.length);
    const match2 = new Array(s2.length);
    let m = 0; // matches
    let t = 0; // transpositions
    for (let i = 0; i < s1.length; i++) {
      const start = Math.max(0, i - max);
      const end = Math.min(i + max + 1, s2.length);
      for (let j = start; j < end; j++) {
        if (match2[j]) continue;
        if (s1[i] !== s2[j]) continue;
        match1[i] = true;
        match2[j] = true;
        m++;
        break;
      }
    }
    if (m === 0) return [0, 0, 0];
    let k = 0;
    for (let i = 0; i < s1.length; i++) {
      if (!match1[i]) continue;
      while (!match2[k]) k++;
      if (s1[i] !== s2[k]) t++;
      k++;
    }
    let l = 0;
    for (let i = 0; i < Math.min(4, s1.length, s2.length); i++) {
      if (s1[i] === s2[i]) l++; else break;
    }
    return [m, t / 2, l];
  }
}

/*****************
 * Setup Wizard  *
 *****************/
function setup() {
  const ss = SpreadsheetApp.getActive();
  const cfgName = 'Config';
  let cfg = ss.getSheetByName(cfgName);
  if (!cfg) cfg = ss.insertSheet(cfgName);

  const headers = [
    'Dest Header', 'Source Header', 'Type (text/number/date)', 'Match Mode (exact/dynamic)',
    'Threshold / Range A', 'Range B', 'Weight (0–1)', 'Output Field? (yes/no)'
  ];
  cfg.clear();
  cfg.getRange(1, 1, 1, headers.length).setValues([headers]);

  // Try to detect Destination & Source sheets
  const dest = ss.getSheetByName('Destination');
  const src = ss.getSheetByName('Source');
  let stubRows = [];
  if (dest && src) {
    const destHeaders = dest.getRange(1, 1, 1, dest.getLastColumn()).getValues()[0];
    const srcHeaders = src.getRange(1, 1, 1, src.getLastColumn()).getValues()[0];
    const destSet = new Set(destHeaders.map(h => normalizeHeader(h)));
    const srcByNorm = {};
    srcHeaders.forEach(h => srcByNorm[normalizeHeader(h)] = h);

    // Build stub rows for intersecting headers
    destHeaders.forEach(h => {
      const key = normalizeHeader(h);
      if (srcByNorm[key]) {
        stubRows.push([h, srcByNorm[key], 'text', 'exact', '', '', 1, 'yes']);
      }
    });
  }

  // If nothing detected, add tip rows
  if (stubRows.length === 0) {
    stubRows = [
      ['ID', 'InvoiceNo', 'text', 'exact', '', '', 1, 'yes'],
      ['Name', 'Customer Name', 'text', 'dynamic', '85', '', 1, 'yes'],
      ['Amount', 'Total', 'number', 'dynamic', '-1', '1', 1, 'yes'],
      ['Date', 'TxnDate', 'date', 'dynamic', '-3d', '+3d', 1, 'yes']
    ];
  }

  if (stubRows.length) cfg.getRange(2, 1, stubRows.length, headers.length).setValues(stubRows);

  SpreadsheetApp.getUi().alert('Config sheet initialized. Review and edit the mappings/rules as needed. Then use Matching Engine → Preview or Run.');
}

/***********************
 * Convenience Exports *
 ***********************/
function similarity() {
  return { text: similarity_text, number: similarity_number, date: similarity_date };
}

/*****************
 * Misc Helpers  *
 *****************/
function buildDiagnosticsHeader(destHeader, srcHeader) {
  return destHeader + '⇄' + srcHeader;
}

/**********************************************
 * ======= EXAMPLE CONFIG ROWS (reference) =======
 * Dest Header,Source Header,Type,Match Mode,Threshold / Range A,Range B,Weight,Output Field?
 * Invoice ID,InvoiceNo,text,exact,,,1,yes
 * Patient Name,Customer Name,text,dynamic,85,,1,yes
 * Amount,Total,number,dynamic,-2,2,1,yes
 * Invoice Date,TxnDate,date,dynamic,-3d,+3d,1,yes
 **********************************************/




















