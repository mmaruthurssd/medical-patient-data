<!DOCTYPE html>
<html>

<head>
  <base target="_top">
  <?!= include("pdf-lib"); ?>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 60px;
    }

    #mainDiv {
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 500px;
    }

    h2 {
      margin-top: 0;
      display: flex;
      justify-content: center;
    }

    .form-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }

    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      box-sizing: border-box;
    }

    button {
      margin-top: 20px;
      width: 100%;
      padding: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
    }

    button:hover {
      background-color: #0056b3;
    }

    #pStatus {
      margin-top: 20px;
      text-align: center;
      font-style: italic;
      color: #555;
    }

    #pProgress {
      margin-top: 20px;
      text-align: center;
      font-style: italic;
      color: #555;
    }

    select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #fff;
      box-sizing: border-box;
      font-size: 14px;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;utf8,<svg fill='gray' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 16px 16px;
    }

    select:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
    }
  </style>
</head>

<body onload="onloadFunction()">
  <div id="mainDiv">
    <div id="container_fillpdf" hidden>
      <h2>Generate PDF Forms</h2>

      <div class="form-group">
        <label for="sheetname">Sheet name:</label>
        <select id="sheetname"></select>
      </div>

      <div class="form-group">
        <label for="formname">Form name:</label>
        <select id="formname">
          <option value="All-Forms">All - Forms</option>
        </select>
      </div>

      <button type="button" onclick="startGeneratingPdfs()">Generate</button>
    </div>

    <div id="container_getInfo" hidden>
      <h2>Add New PDF-Form Template</h2>

      <div class="form-group">
        <label for="formname_newTemplate">Form Name:</label>
        <input type="text" id="formname_newTemplate" value="" />
      </div>

      <div class="form-group">
        <label for="templatelink">Template link:</label>
        <input type="text" id="templatelink" value="" />
      </div>

      <div class="form-group">
        <label for="folderlink">Destination folder link:</label>
        <input type="text" id="folderlink" value="" />
      </div>

      <div class="form-group">
        <label for="outputfilename">Output file name:</label>
        <input type="text" id="outputfilename" value="" />
      </div>

      <button type="button" onclick="submitForm_addNewTemplate()">Submit</button>
    </div>

    <p id="pStatus">Loading...</p>
    <p id="pProgress"></p>
  </div>

  <script>
    const delay = ms => new Promise(res => setTimeout(res, ms));
    
        var processtype = null;
        var sourcesheet = null;
        var bAllForms = null;
        var allFormNames = [];
        var vProcessedForms = 0;
        var vLastCountForms = 0;
        var vTotalForms = 0;

        var container_fillpdf = document.getElementById("container_fillpdf");
        var container_getInfo = document.getElementById("container_getInfo");
        var pStatus = document.getElementById("pStatus");
        var pProgress = document.getElementById("pProgress");

        var formname_newTemplate = document.getElementById("formname_newTemplate");
        var templatelink = document.getElementById("templatelink");
        var folderlink = document.getElementById("folderlink");
        var outputfilename = document.getElementById("outputfilename");

        var sheetname = document.getElementById("sheetname");
        var formname = document.getElementById("formname");

        var sFormname = "";

        function submitForm_addNewTemplate() {
          var objValues = assignValues_();
          if(!isValid_(objValues)) return;

          updateStatus_("Adding new template...");

          extractFieldsFromPDF(objValues);
        }

        function isValid_(objValues){
          if(objValues["formname"].toString() == ""){
            formname.focus();
            alert("Please enter [Form Name].");
            return false;
          }
          if(objValues["templatelink"].toString() == ""){
            templatelink.focus();
            alert("Please enter [Template link].");
            return false;
          }
          if(objValues["folderlink"].toString() == ""){
            folderlink.focus();
            alert("Please enter [Folder link].");
            return false;
          }
          if(objValues["outputfilename"].toString() == ""){
            outputfilename.focus();
            alert("Please enter [Output file name].");
            return false;
          }
          return true;
        }

        function assignValues_(){
          var objValues = {};

          objValues.formname = formname_newTemplate.value;
          objValues.templatelink = templatelink.value;
          objValues.folderlink = folderlink.value;
          objValues.outputfilename = outputfilename.value;

          return objValues;
        }

        function startGeneratingPdfs(){
          sourcesheet = sheetname.value;
          sFormname = formname.value;
          if(sFormname == "All-Forms"){
            bAllForms = true;
          }
          fillPdf();
        }

        async function fillPdf() {

            disabled_(true);
        
            updateStatus_(`Connecting to sheet [${sourcesheet}]`);

            var allFormsToGenerate = [];
            allFormsToGenerate.push(sFormname);

            if(bAllForms){
              allFormsToGenerate = allFormNames;
            }

            vTotalForms = allFormsToGenerate.length;

            allFormsToGenerate.map(async fn => {
              
              while(vLastCountForms != vProcessedForms){
                await delay(100);
              }
              vLastCountForms++;

              sFormname = fn;
              console.log(sFormname);

              var vProcessed = 0;
              var vLastCount = 0;
              var vSuccess = 0;
              var vFailed = 0;
              var vTotal = 0;

              google.script.run.withSuccessHandler(async response => {

                      // console.log(response);

                      if(!response){
                        updateStatus_("faced error while connecting to sheet.");
                        alert("faced error while connecting to sheet.");
                        return;
                      }

                      updateStatus_(`Connected to sheet [${sourcesheet}]<br>Generating PDfs...`);

                      const base64Data = response.template;
                      const dataObj = response.dataObj;
                      const config = response.config;
                      const objHeaders = response.objHeaders;

                      vTotal = dataObj.length;
                      
                      if(dataObj == false){
                        updateStatus_(`No data to process for sheet: [${sourcesheet}]`);
                        alert(`No data to process for sheet: [${sourcesheet}]`);
                        return;
                      } 

                      const byteCharacters = atob(base64Data);
                      const byteNumbers = new Array(byteCharacters.length);
                      for (let i = 0; i < byteCharacters.length; i++) {
                          byteNumbers[i] = byteCharacters.charCodeAt(i);
                      }
                      const pdfBytes = new Uint8Array(byteNumbers);

                      dataObj.forEach(async data =>{
                          
                        while(vLastCount != vProcessed){
                          await delay(100);
                        }
                        vLastCount++;

                        updateProgress_({vSuccess,vFailed,vProcessed,vTotal});

                        if(data[`Form link [${sFormname}]`].toString().trim() == ""){
                          
                          const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                          const form = pdfDoc.getForm();

                          const objFields = getFieldDetails_(form);

                          var newFilename = config.outputfilename;
                          Object.entries(data).forEach(([h,v]) => {
                            newFilename = newFilename.replace(`{${h}}`,v).toString().trim();
                          });

                          Object.entries(objFields).forEach(([f,t])=>{
                            // console.log(f);
                            // console.log(config);
                            // console.log(config.formfields);
                            if(!config.formfields.includes(f)) return;
                            var vIndex = config.formfields.indexOf(f);
                            var sHeader = config.sheetfields[vIndex];

                            if(!data[sHeader]) return;

                            switch(t){
                              case "TextBox":
                              try{
                                form.getTextField(f).setText(data[sHeader].toString());
                              }catch(err){console.log(err);}
                              break;
                            }
                          });

                          // form.flatten();
                          const modifiedBytes = await pdfDoc.save();
                          const base64New = uint8ToBase64(modifiedBytes);

                          google.script.run.withSuccessHandler(url => {
                                  vProcessed++;
                                  vSuccess++;
                                  updateProgress_({vSuccess,vFailed,vProcessed,vTotal});
                              })
                              .withFailureHandler(err => {
                                vProcessed++;
                                vFailed++;
                                updateProgress_({vSuccess,vFailed,vProcessed,vTotal});
                              })
                              .savePDFToDrive({base64Data:base64New, filename:`${newFilename}.pdf`, folderlink:config.folderlink, sourcesheet, vRow:data["v$Row"],formname:sFormname});

                        }else{
                          vProcessed++;
                          updateProgress_({vSuccess,vFailed,vProcessed,vTotal});
                        }
                      });

                      while(vProcessed != dataObj.length){
                        await delay(100);
                      }
                      // updateProgress_({vSuccess,vFailed,vProcessed,vTotal});

                  })
                .withFailureHandler(err => {updateStatus_("faced error while connecting to sheet.");alert("faced error while connecting to sheet.");})
                .getAllDataForGeneration({sourcesheet,formname:sFormname});

            });

        }

        async function extractFieldsFromPDF(objValues) {
          disabled_(true);
            
          google.script.run
              .withSuccessHandler(async response => {

                  if(!response) return;

                  const base64Data = response;

                  const byteCharacters = atob(base64Data);
                  const byteNumbers = new Array(byteCharacters.length);
                  for (let i = 0; i < byteCharacters.length; i++) {
                      byteNumbers[i] = byteCharacters.charCodeAt(i);
                  }
                  const pdfBytes = new Uint8Array(byteNumbers);

                  const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                  const form = pdfDoc.getForm();

                  const objFields = getFieldDetails_(form);

                  const fields = Object.entries(objFields).map(([key, value]) => key);

                  // console.log({objFields});
                  // console.log({fields});

                  if (fields.length > 0) {
                    objValues.fields = fields;

                      google.script.run
                          .withSuccessHandler(url => {
                            updateStatus_("Template Info has been recorded.");
                            // disabled_(false);
                          })
                          .withFailureHandler(err => {disabled_(false);updateStatus_("Error adding new template.");alert("Error adding new template");})
                          .recordNewTemplateConfig(objValues);
                  }else{
                    updateStatus_("No fields detected in the file.");
                  }
              })
              .withFailureHandler(err => {disabled_(false);updateStatus_("Error loading template.");alert("Error loading template");})
              .getTemplatePDF(objValues.templatelink);

          disabled_(true);
        }

        function getFieldDetails_(form) {

            var obj = {};

            const PDFName = PDFLib.PDFName;
            const fields = form.getFields();
            fields.forEach(f => {

                const name = f.getName();
                const acroField = f.acroField;
                const dict = acroField.dict;

                const type = dict.get(PDFName.of('FT'))?.encodedName || 'Unknown';
                let fieldType = '';

                const flagsObj = dict.get(PDFName.of('Ff'));
                const flags = flagsObj?.numberValue || 0;

                switch (type) {
                    case "/Btn":
                        if ((flags & 0x10000) !== 0) {
                            fieldType = 'PushButton';
                        } else if ((flags & 0x8000) !== 0) {
                            fieldType = 'RadioButton';
                        } else {
                            fieldType = 'CheckBox';
                        }
                        break;
                    case "/Ch":
                        if ((flags & 0x20000) !== 0) {
                            fieldType = 'ComboBox';
                        } else if ((flags & 0x200000) !== 0) {
                            fieldType = 'ListBox (Multi)';
                        } else {
                            fieldType = 'ListBox';
                        }
                        break;
                    case "/Tx":
                        fieldType = "TextBox";
                        break;
                }

                obj[name] = fieldType;
            });
            return obj;
        }

        function uint8ToBase64(uint8Array) {
            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < uint8Array.length; i += chunkSize) {
                const chunk = uint8Array.subarray(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }

        function makeOptionsFromArray_(optionsArray, select) {
          optionsArray.forEach(optionText => {
            const option = document.createElement('option');
            option.value = optionText;
            option.textContent = optionText;
            select.appendChild(option);
          });
        }

        function getListsForGeneration_response(response){
          // console.log(response);

          if(!response){
            updateStatus_("Error.<br>Something went wrong while connecting to the sheet.");
            return;
          }
          
          if(response.sheetnames) makeOptionsFromArray_(response.sheetnames, sheetname);
          if(response.formnames) makeOptionsFromArray_(response.formnames, formname); allFormNames = response.formnames;
          
          if(sourcesheet) sheetname.value = sourcesheet;

          container_fillpdf.hidden = false;
          updateStatus_("");
        }

        function onloadFunction() {
            setTimeout(onLoadContinue, 1000);
        }

        function onLoadContinue() {
            if (!processtype) {
                updateStatus_("Invalid link.<br>Please open via button from google sheet.");
                return;
            }

            switch (processtype) {
                case "generate":
                  google.script.run.withSuccessHandler(getListsForGeneration_response).withFailureHandler(getListsForGeneration_response).getListsForGeneration();
                  break;
                case "gettemplateinfo":
                    container_getInfo.hidden = false;
                    updateStatus_("");
                    formname_newTemplate.focus()
                    break;
                default:
                  updateStatus_("Invalid link.<br>Please open via button from google sheet.");
                  break;
            }
        }

        function updateStatus_(stext) {
            pStatus.innerHTML = stext;
        }
        function updateProgress_({vSuccess,vFailed,vProcessed,vTotal}) {

            var sfn = sFormname + '';

            if(vProcessed == vTotal){
              vProcessedForms++;
              sfn = '';
            }

            if(vProcessedForms == vTotalForms){
              updateStatus_(`All Records processed for sheet [${sourcesheet}]`);
              pProgress.innerHTML = '';
              return;
            }

            var stext = `
            ${vProcessedForms}/${vTotalForms} Forms processed.<br><br>

            Generating form: [${sfn}].<br><br>

            ${vProcessed}/${vTotal} records processed.<br>
            ${vSuccess} successfully generated.<br>
            ${vFailed} failed to generate.`;
            pProgress.innerHTML = stext;
        }

        const waitTime = async () => {
            await delay(5000);
        }

        google.script.url.getLocation(function (location) {
            processtype = location.parameter.processtype;
            sourcesheet = location.parameter.sourcesheet;
        });


        function disabled_(bDisable) {
            const allElements = document.getElementsByTagName('*');

            for (const ele of allElements) {
                try {
                    var sTag = ele.nodeName.toLowerCase();
                    var sType = ele.type.toLowerCase();
                    var sName = ele.name.toLowerCase();
                    if (["button", "input", "select", "textarea"].includes(sTag)) {
                        ele.disabled = bDisable;
                    }
                } catch (err) {
                }
            }
        }
  </script>
</body>

</html>